%!TEX root = ts.tex

\rSec1[Concurrency2.SafeReclamation.HP]{Hazard pointers}

\rSec2[Concurrency2.SafeReclamation.HP.general]{General}

Editor's note: This section was mistakenly unlabeled in P1121R3.

\pnum
A hazard pointer is a single-writer multi-reader pointer that can be owned by at most one thread at any time. Only the owner of the hazard pointer can set its value, while any number of threads may read its value. The owner thread sets the value of a hazard pointer to point to an object in order to indicate to concurrent threads --- that may delete such an object --— that the object is not yet safe to delete.

\pnum
A class type \tcode{T} is \defn{hazard-protectable} if it has exactly one public base class of type \linebreak \tcode{hazard_pointer_obj_base<T,D>} for some \tcode{D} and no base classes of type \tcode{hazard_pointer_obj_base<T’,D’>} for any other combination \tcode{T’}, \tcode{D’}. An object is \defn{hazard-protectable} if it is of hazard-protectable type.

\pnum
The span between creation and destruction of a hazard pointer \defn{h} is partitioned into a series of \defn{protection epochs}; in each protection epoch, \defn{h} either is \defn{associated with} a hazard-protectable object, or is \defn{unassociated}. Upon creation, a hazard pointer is unassociated. Changing the association (possibly to the same object) initiates a new protection epoch and ends the preceding one.

\pnum
A hazard pointer \defn{belongs to} exactly one \defn{domain}. 

\pnum
An object of type \tcode{hazard_pointer} is either empty or \defn{owns} a hazard pointer. Each hazard pointer is owned by exactly one object of type \tcode{hazard_pointer}. [ \defn{Note}: An empty \tcode{hazard_pointer} object is different from a \tcode{hazard_pointer} object that owns an unassociated hazard pointer. An empty tcode{hazard_pointer} object does not own any hazard pointers. --- \defn{end note} ]

\pnum
An object \tcode{x} of hazard-protectable type \tcode{T} is \defn{retired} to a domain with a deleter of type \tcode{D} when the member function \tcode{hazard_pointer_obj_base<T,D>::retire} is invoked on \tcode{x}. Any given object \tcode{x} shall be retired at most once.

\pnum
A retired object \tcode{x} is \defn{reclaimed} by invoking its deleter with a pointer to \tcode{x}.

\pnum
A hazard-protectable object \tcode{x} is \defn{definitely reclaimable} in a domain \defn{dom} with respect to
an evaluation A if:

\begin{itemize}
\item \tcode{x} is not reclaimed, and
\item \tcode{x} is retired to \defn{dom} in an evaluation that happens before A, and
\item for all hazard pointers \defn{h} that belong to \defn{dom}, the end of any protection epoch where \defn{h} is associated with \tcode{x} happens before A.
\end{itemize}

\pnum
A hazard-protectable object \tcode{x} is \defn{possibly reclaimable} in domain \defn{dom} with respect to an
evaluation A if:
\begin{itemize}
\item \tcode{x} is not reclaimed; and
\item \tcode{x} is retired to \defn{dom} in an evaluation R and A does not happen before R; and
\item for all hazard pointers \defn{h} that belong to \defn{dom}, A does not happen before the end of
any protection epoch where \defn{h} is associated with \tcode{x}; and
\item for all hazard pointers \defn{h} belonging to \defn{dom} and for every protection epoch E of \defn{h}
during which \defn{h} is associated with \tcode{x}:
\begin{itemize}
  \item A does not happen before the end of E, and
  \item if the beginning of E happens before \tcode{x} is retired, the end of E strongly
happens before A, and
  \item if E began by an evaluation of \tcode{try_protect} with argument \tcode{src}, label its
atomic load operation L. If there exists an atomic modification B on \tcode{src} such that L observes a modification that is modification-ordered before B, and B happens before \tcode{x} is retired, the end of E strongly happens before A. [ \defn{Note}: In typical use, a store to \tcode{src} sequenced before retiring \tcode{x} will be such an atomic operation B. --- \defn{end note} ]
\end{itemize}
[ \defn{Note}: The latter two conditions convey the informal notion that a protection epoch that began before retiring \tcode{x}, as implied either by the happens-before relation or the coherence order of some source, delays the reclamation of \tcode{x}. --- \defn{end note} ]
\end{itemize}

[ \defn{Example}: The following example shows how hazard pointers allow updates to be carried out in the presence of concurrent readers. The object of type \tcode{hazard_pointer} in \tcode{print_name} protects the object \tcode{*ptr} from being reclaimed by \tcode{ptr->retire} until the end of the protection epoch.

\begin{codeblock}
struct Name : public hazard_pointer_obj_base<Name> { /* details */ };
atomic<Name*> name;

// called often and in parallel!
void print_name() {
  hazard_pointer h = make_hazard_pointer();
  Name* ptr = h.protect(name); /* Protection epoch starts */
  /* ... safe to access *ptr ... */
} /* Protection epoch ends. */

// called rarely, but possibly concurrently with print_name
void update_name(Name* new_name) {
  Name* ptr = name.exchange(new_name);
  ptr->retire();
}
\end{codeblock}
--— \defn{end example} ]


\rSec2[Concurrency2.SafeReclamation.HP.syn]{Header \tcode{<hazard_pointer>} synopsis}

\begin{codeblock}
namespace std::experimental::inline concurrency_v2 {
  // \ref{Concurrency2.SafeReclamation.HP.domain}, class hazard_pointer_domain
  class hazard_pointer_domain;
  // \ref{Concurrency2.SafeReclamation.HP.domain.default}, Default hazard_pointer_domain
  hazard_pointer_domain& hazard_pointer_default_domain() noexcept;
  // \ref{Concurrency2.SafeReclamation.HP.cleanup}, Clean up
  void hazard_pointer_clean_up(hazard_pointer_domain& domain = hazard_pointer_default_domain())
    noexcept;
  // \ref{Concurrency2.SafeReclamation.HP.base}, class template hazard_pointer_obj_base
  template <typename T, typename D = default_delete<T>> class hazard_pointer_obj_base;
  // \ref{Concurrency2.SafeReclamation.HP.holder}, class hazard_pointer
  class hazard_pointer;
  // \ref{Concurrency2.SafeReclamation.HP.make}, Construct non-empty hazard_pointer
  hazard_pointer make_hazard_pointer(
    hazard_pointer_domain& domain = hazard_pointer_default_domain());
  // \ref{Concurrency2.SafeReclamation.HP.special}, Hazard pointer swap
  void swap(hazard_pointer&, hazard_pointer&) noexcept;
}
\end{codeblock}

\rSec2[Concurrency2.SafeReclamation.HP.domain]{Class \tcode{hazard_pointer_domain}}

\rSec3[Concurrency2.SafeReclamation.HP.domain.general]{General}

\pnum
The number of unreclaimed possibly-reclaimable objects retired to a domain is bounded.
The bound is implementation-defined. [ \defn{Note}: The bound can be independent of other
domains and can be a function of the number of hazard pointers belonging to the
domain, the number of threads that retire objects to the domain, and the number of
threads that use hazard pointers belonging to the domain. --- \defn{end note} ]

\pnum
Concurrent access to a domain does not incur a data race ([intro.races)].

\begin{codeblock}
class hazard_pointer_domain {
public:
  hazard_pointer_domain() noexcept;
  explicit hazard_pointer_domain(pmr::polymorphic_allocator<byte> poly_alloc) noexcept;

  hazard_pointer_domain(const hazard_pointer_domain&) = delete;
  hazard_pointer_domain& operator=(const hazard_pointer_domain&) = delete;

  ~hazard_pointer_domain();
};
\end{codeblock}

\rSec3[Concurrency2.SafeReclamation.HP.domain.mem]{Member functions}

\tcode{hazard_pointer_domain() noexcept;}

\pnum
\defn{Effects}: Equivalent to
\begin{codeblock}
hazard_pointer_domain({});
\end{codeblock}

\tcode{explicit hazard_pointer_domain(pmr::polymorphic_allocator<byte> poly_alloc) noexcept;}

\pnum
\defn{Remarks}: All allocation and deallocation related to hazard pointers belonging to this
domain use a copy of \tcode{poly_alloc}.
\\

\tcode{\~hazard_pointer_domain();}

\pnum
\defn{Preconditions}: All hazard pointers belonging to \tcode{*this} have been destroyed.

\pnum
\defn{Effects}: Reclaims all objects retired to this domain that have not yet been reclaimed.
\\

\rSec2[Concurrency2.SafeReclamation.HP.domain.default]{Default \tcode{hazard_pointer_domain}}

\tcode{hazard_pointer_domain\& hazard_pointer_default_domain() noexcept;}

\pnum
\defn{Returns}: A reference to the default \tcode{hazard_pointer_domain}.

\pnum
\defn{Remarks}: The default domain has an unspecified allocator and has static storage
duration. The initialization of the default domain strongly happens before this function
returns; the sequencing is otherwise unspecified.
\\

\rSec2[Concurrency2.SafeReclamation.HP.cleanup]{Clean up}

\tcode{void hazard_pointer_clean_up(}\\
\hspace*{1.1em}\tcode{hazard_pointer_domain\& domain = hazard_pointer_default_domain()) noexcept;}

\pnum
\defn{Effects}: May reclaim possibly-reclaimable objects retired to \tcode{domain}.

\pnum
\defn{Postconditions}: All definitely-reclaimable objects retired to \tcode{domain} have been reclaimed.

\pnum
\defn{Synchronization}: The completion of the deleter for each reclaimed object synchronizes
with the return from this function call.
\\

\rSec2[Concurrency2.SafeReclamation.HP.base]{Class template \tcode{hazard_pointer_obj_base}}

\begin{codeblock}
template <typename T, typename D = default_delete<T>>
class hazard_pointer_obj_base {
public:
  void retire(
    D d = D(),
    hazard_pointer_domain& domain = hazard_pointer_default_domain()) noexcept;
  void retire(hazard_pointer_domain& domain) noexcept;
protected:
  hazard_pointer_obj_base() = default;
private:
  D deleter; // exposition only
};
\end{codeblock}

\pnum
A client-supplied template argument \tcode{D} shall be a function object type ([function.object])
for which, given a value \tcode{d} of type \tcode{D} and a value \tcode{ptr} of type \tcode{T*}, the expression \tcode{d(ptr)} is valid and has the effect of disposing of the pointer as appropriate for that deleter.

\pnum
The behavior of a program that adds specializations for \tcode{hazard_pointer_obj_base} is undefined.

\pnum
\tcode{D} shall meet the requirements for Cpp17DefaultConstructible and Cpp17MoveAssignable.

\pnum
\tcode{T} may be an incomplete type.
\\

\tcode{void retire(}\\
\hspace*{1.1em}\tcode{D d = D(),}\\
\hspace*{1.1em}\tcode{hazard_pointer_domain\& domain = hazard_pointer_default_domain()) noexcept;}

\pnum
\defn{Mandates}: \tcode{T} is a hazard-protectable type.

\pnum
\defn{Preconditions}: \tcode{*this} is a base class subobject of an object x of type \tcode{T}. x is not retired.
Move-assigning \tcode{D} from \tcode{d} does not throw an exception. The expression \tcode{d(addressof(x))} has well-defined behavior and does not throw an exception.

\pnum
\defn{Effects}: Move-assigns \tcode{d} to \tcode{deleter}, thereby setting it as the deleter of x, then retires x
to domain.

\pnum
Invoking the retire function may reclaim possibly-reclaimable objects retired to domain.
\\

\tcode{void retire(hazard_pointer_domain\& domain) noexcept;}

\pnum
\defn{Effects}: Equivalent to
\begin{codeblock}retire(D(), domain);
\end{codeblock}

\rSec2[Concurrency2.SafeReclamation.HP.holder]{Class \tcode{hazard_pointer}}

\rSec3[Concurrency2.SafeReclamation.HP.holder.syn]{Synopsis}

Editor's note: This section was mistakenly unlabeled in P1121R3.

\begin{codeblock}
class hazard_pointer {
public:
  hazard_pointer() noexcept;

  hazard_pointer(hazard_pointer&&) noexcept;
  hazard_pointer& operator=(hazard_pointer&&) noexcept;

  ~hazard_pointer();
  
  [[nodiscard]] bool empty() const noexcept;
  
  template <typename T> T* protect(const atomic<T*>& src) noexcept;
  
  template <typename T> bool try_protect(T*& ptr, const atomic<T*>& src) noexcept;
  
  template <typename T> void reset_protection(const T* ptr) noexcept;
  void reset_protection(nullptr_t = nullptr) noexcept;
  
  void swap(hazard_pointer&) noexcept;
};
\end{codeblock}

\rSec3[Concurrency2.SafeReclamation.HP.holder.ctor]{Constructors}

\tcode{hazard_pointer() noexcept;}

\pnum
\defn{Postconditions}: \tcode{*this} is empty.
\\

\tcode{hazard_pointer(hazard_pointer\&\& other) noexcept;}

\pnum
\defn{Postconditions}: If \tcode{other} is empty, \tcode{*this} is empty. Otherwise, \tcode{*this} owns the hazard pointer originally owned by \tcode{other}; \tcode{other} is empty.
\\

\rSec3[Concurrency2.SafeReclamation.HP.holder.dtor]{Destructor}

\tcode{\~hazard_pointer();}

\pnum
\defn{Effects}: If \tcode{*this} is not empty, destroys the hazard pointer owned by \tcode{*this}, thereby ending its current protection epoch.

\rSec3[Concurrency2.SafeReclamation.HP.holder.assign]{Assignment}

\tcode{hazard_pointer\& operator=(hazard_pointer\&\& other) noexcept;}

\pnum
\defn{Effects}: If \tcode{this == \&other} is true, no effect. Otherwise, if \tcode{*this} is not empty, destroys
the hazard pointer owned by \tcode{*this}, thereby ending its current protection epoch.

\pnum
\defn{Postconditions}: If \tcode{other} was empty, \tcode{*this} is empty. Otherwise, \tcode{*this} owns the hazard
pointer originally owned by other. If \tcode{this != \&other} is true, \tcode{other} is empty.

\pnum
\defn{Returns}: \tcode{*this}.
\\

\rSec3[Concurrency2.SafeReclamation.HP.holder.mem]{Member functions}

\tcode{[[nodiscard]] bool empty() const noexcept;}

\pnum
\defn{Returns}: true if and only if \tcode{*this} is empty.
\\

\tcode{template <typename T> T* protect(const atomic<T*>\& src) noexcept;}

\pnum
\defn{Effects}: Equivalent to
\begin{codeblock}
T* ptr = src.load(memory_order_relaxed);
while (!try_protect(ptr, src)) {}
return ptr;
\end{codeblock}

\tcode{template <typename T> bool try_protect(T*\& ptr, const atomic<T*>\& src) noexcept;}

\pnum
\defn{Mandates}: T is a hazard-protectable type.

\pnum
\defn{Preconditions}: *this is not empty.

\pnum
\defn{Effects}:
\begin{itemize}
\item Initializes a variable \tcode{old} of type \tcode{T*} with the value of \tcode{ptr}.
\item Evaluates the function call \tcode{reset_protection(old)}.
\item Assigns the value of \tcode{src.load(std::memory_order_acquire)} to \tcode{ptr}.
\item If \tcode{old == ptr} is false, evaluates the function call \tcode{reset_protection()}.
\end{itemize}

\pnum
\defn{Returns}: \tcode{old == ptr}. [ \defn{Note}: It is possible for \tcode{try_protect} to return true when \tcode{ptr} is a null pointer. --— \defn{end note} ]

\pnum
\defn{Complexity}: Constant.
\\

\tcode{template <typename T>}\\
\hspace*{1.1em}\tcode{void reset_protection(const T* ptr) noexcept;}


\pnum
\defn{Mandates}: \tcode{T} is a hazard-protectable type.

\pnum
\defn{Preconditions}: \tcode{*this} is not empty.

\pnum
\defn{Effects}: If \tcode{ptr} is a null pointer value, invokes \tcode{reset_protection()}. Otherwise, associates the hazard pointer owned by \tcode{*this} with \tcode{*ptr}, thereby ending the current protection epoch.
\\

\tcode{void reset_protection(nullptr_t = nullptr) noexcept;}

\pnum
\defn{Preconditions}: \tcode{*this} is not empty.

\pnum
\defn{Postconditions}: The hazard pointer owned by \tcode{*this} is unassociated.
\\

\tcode{void swap(hazard_pointer\& other) noexcept;}

\pnum
\defn{Effects}: Swaps the hazard pointer ownership of this object with that of other. [ Note: The owned hazard pointers, if any, remain unchanged during the swap and continue to be associated with the respective objects that they were protecting before the swap, if any. No protection epochs are ended or initiated. — end note ]

\pnum
\defn{Complexity}: Constant.
\\

\rSec2[Concurrency2.SafeReclamation.HP.make]{\tcode{make_hazard_pointer}}

\tcode{hazard_pointer make_hazard_pointer(}\\
\hspace*{1.1em}\tcode{hazard_pointer_domain\& domain = hazard_pointer_default_domain());}

\pnum
\defn{Effects}: Constructs a hazard pointer belonging to \tcode{domain}.

\pnum
\defn{Returns}: A \tcode{hazard_pointer} object that owns the newly-constructed hazard pointer.

\pnum
\defn{Throws}: Any exception thrown by the allocator of \tcode{domain}.
\\

\rSec2[Concurrency2.SafeReclamation.HP.special]{\tcode{hazard_pointer} specialized algorithms}

\tcode{void swap(hazard_pointer\& a, hazard_pointer\& b) noexcept;}

\pnum
\defn{Effects}: Equivalent to \tcode{a.swap(b)}.
\\
