%!TEX root = ts.tex

\rSec0[synchronizedvalue]{Synchronized Value}

\rSec1[synchronizedvaluec.general]{General}

This clause describes Synchronized Value access. 

\subsubsection{x Synchronized Values}\label{x-synchronized-values}}

This section describes a class template to provide locked access to a
value in order to facilitate the construction of race-free programs.

\mbox{}%
\hypertarget{header-experimentalsynchronized_value-synopsis}{%
\paragraph{Header
\textless experimental/synchronized\_value\textgreater{}
synopsis}\label{header-experimentalsynchronized_value-synopsis}}

\begin{verbatim}
namespace std::experimental::inline concurrency_v2 {
    template<class T>
    class synchronized_value;

    template<class F,class ... ValueTypes>
    invoke_result_t<F, ValueTypes&...> apply(
        F&& f,synchronized_value<ValueTypes>&... values);
}
\end{verbatim}

\mbox{}%
\hypertarget{x.1-class-template-synchronized_value}{%
\paragraph{\texorpdfstring{x.1 Class template
\texttt{synchronized\_value}}{x.1 Class template synchronized\_value}}\label{x.1-class-template-synchronized_value}}

\begin{verbatim}
namespace std::experimental::inline concurrency_v2 {
  template<class T>
    class synchronized_value
    {
    public:
        synchronized_value(synchronized_value const&) = delete;
        synchronized_value& operator=(synchronized_value const&) = delete;

        template<class ... Args>
        synchronized_value(Args&& ... args);

    private:
        T value; // exposition only
        mutex mut; // exposition only
    };

template<class T>
synchronized_value(T)
-> synchronized_value<T>;
}
\end{verbatim}

An object of type \texttt{synchronized\_value\textless{}T\textgreater{}}
wraps an object of type \texttt{T}. The wrapped object can be accessed
by passing a callable object or function to \texttt{apply}. All such
accesses are done with a lock held to ensure that only one thread may be
accessing the wrapped object for a given \texttt{synchronized\_value} at
a time.

\begin{verbatim}
template<class ... Args>
synchronized_value(Args&& ... args);
\end{verbatim}

\begin{description}
\item[Constraints:]
\begin{itemize}
\tightlist
\item[]
\item
  \texttt{(sizeof...(Args)\ !=\ 1)} is \texttt{true} or
  \texttt{(!same\_as\textless{}synchronized\_value,remove\_cvref\_t\textless{}Args\textgreater{}\textgreater{}\ \&\&...)}
  is \texttt{true}
\item
  \texttt{is\_constructible\_v\textless{}T,Args...\textgreater{}} is
  \texttt{true}
\end{itemize}
\item[Effects:]
Direct-non-list-initializes \emph{\texttt{value}} with
\texttt{std::forward\textless{}Args\textgreater{}(args)...}.
\item[Throws:]
Any exceptions emitted by the initialization of \emph{\texttt{value}}.\\
\texttt{system\_error} if any necessary resources cannot be acquired.
\end{description}

\mbox{}%
\hypertarget{x.2-apply-function}{%
\paragraph{\texorpdfstring{x.2 \texttt{apply}
function}{x.2 apply function}}\label{x.2-apply-function}}

\begin{verbatim}
    template<class F,class ... ValueTypes>
    invoke_result_t<F, ValueTypes&...> apply(
        F&& f,synchronized_value<ValueTypes>&... values);
\end{verbatim}

\begin{description}
\item[Constraints:]
\texttt{sizeof...(values)\ !=\ 0} is \texttt{true}.
\item[Effects:]
Equivalent to:

\begin{verbatim}
    scoped_lock lock(values.mut...);
    return invoke(std::forward<F>(f),values.value...);
\end{verbatim}

{[}Note: A single instance of \texttt{synchronized\_value} can not be
passed more than once to the same invocation of \texttt{apply}.
{[}Example:

\begin{verbatim}
      synchronized_value<int> sv;
      void f(int,int);
      apply(f,sv,sv); // undefined behaviour, sv passed more than once to same call
\end{verbatim}

---End Example{]} ---End Note{]}\\
{[}Note: The invocation of \texttt{f} can not call \texttt{apply}
directly or indirectly passing any of \texttt{values...}. ---End Note{]}
\end{description}

